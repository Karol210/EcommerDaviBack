---
description: Capa transactional para operaciones de consulta y persistencia a BD
globs: ["**/service/**/transactional/**/*.java"]
alwaysApply: true
---

# üíæ Capa Transactional - Acceso a Datos

## üìã TL;DR

- ‚úÖ Capacidad dedicada para consultas y persistencia a base de datos
- ‚úÖ Centraliza TODAS las operaciones con repositories
- ‚úÖ Ubicaci√≥n: `service/{dominio}/transactional/`
- ‚úÖ Interface + Implementaci√≥n con `@Transactional`
- ‚ùå NO acceder a repositories desde ServiceImpl

## üö® Reglas Principales

1. **Separaci√≥n Obligatoria**: TODAS las operaciones de BD (findBy, save, delete, exists) deben estar en capacidad `transactional/`
2. **Ubicaci√≥n**: `service/{dominio}/transactional/{Dominio}TransactionalService[Impl].java`
3. **Anotaciones**: `@Transactional` en m√©todos de escritura, `@Transactional(readOnly = true)` en consultas
4. **Interface siempre**: Crear interface `*TransactionalService` e implementaci√≥n `*TransactionalServiceImpl`
5. **ServiceImpl NO accede a repositories**: Coordinador delega TODO a capacidad transactional
6. **Logs debug**: Usar `log.debug()` para operaciones, evitar `log.info()` innecesario

## üìä Referencia R√°pida

### Tipos de Operaciones Transactionales

| Tipo Operaci√≥n | M√©todo Ejemplo | Anotaci√≥n | Retorno |
|---|---|---|---|
| **Consulta simple** | `findById(Integer id)` | `@Transactional(readOnly = true)` | `Optional<Entity>` |
| **Consulta con throw** | `findByIdOrThrow(Integer id)` | `@Transactional(readOnly = true)` | `Entity` (lanza excepci√≥n) |
| **Consulta lista** | `findAllByCartId(Integer cartId)` | `@Transactional(readOnly = true)` | `List<Entity>` |
| **Verificaci√≥n** | `existsByCartAndProduct(...)` | `@Transactional(readOnly = true)` | `boolean` |
| **Crear/Actualizar** | `save(Entity entity)` | `@Transactional` | `Entity` |
| **Eliminar uno** | `delete(Entity entity)` | `@Transactional` | `void` |
| **Eliminar m√∫ltiples** | `deleteAllByCartId(Integer id)` | `@Transactional` | `void` |
| **Buscar o crear** | `findOrCreate(Integer id)` | `@Transactional` | `Entity` |

### Nomenclatura de M√©todos

| Patr√≥n | Prop√≥sito | Ejemplo |
|---|---|---|
| `find*` | Consulta que retorna Optional | `findById`, `findByCartAndProduct` |
| `find*OrThrow` | Consulta que lanza excepci√≥n si no existe | `findCartItemById`, `findUserById` |
| `findAll*` | Consulta que retorna lista | `findAllByCartId`, `findAllActive` |
| `exists*` | Verificaci√≥n booleana | `existsByCartAndProduct`, `existsByEmail` |
| `save*` | Crear o actualizar | `saveCartItem`, `saveUser` |
| `delete*` | Eliminar uno | `deleteCartItem`, `deleteUser` |
| `deleteAll*` | Eliminar m√∫ltiples | `deleteAllByCartId`, `deleteAllInactive` |
| `findOrCreate*` | Buscar o crear si no existe | `findOrCreateCart`, `findOrCreateSession` |

### Estructura de Archivos

```
service/{dominio}/
‚îú‚îÄ‚îÄ transactional/
‚îÇ   ‚îú‚îÄ‚îÄ {Dominio}TransactionalService.java          (Interface)
‚îÇ   ‚îî‚îÄ‚îÄ {Dominio}TransactionalServiceImpl.java      (Implementaci√≥n)
‚îú‚îÄ‚îÄ validation/
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ builder/
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ {Dominio}Service.java                           (Interface principal)
‚îî‚îÄ‚îÄ {Dominio}ServiceImpl.java                       (Coordinador)
```

**Ejemplo:**
```
service/cartitem/
‚îú‚îÄ‚îÄ transactional/
‚îÇ   ‚îú‚îÄ‚îÄ CartItemTransactionalService.java
‚îÇ   ‚îî‚îÄ‚îÄ CartItemTransactionalServiceImpl.java
‚îú‚îÄ‚îÄ validation/
‚îÇ   ‚îî‚îÄ‚îÄ CartItemValidationServiceImpl.java
‚îú‚îÄ‚îÄ builder/
‚îÇ   ‚îî‚îÄ‚îÄ CartItemBuilderServiceImpl.java
‚îú‚îÄ‚îÄ CartItemService.java
‚îî‚îÄ‚îÄ CartItemServiceImpl.java
```

## ‚úÖ Ejemplos

### Ejemplo 1: Interface Transactional Completa

```java
package com.ecommerce.davivienda.service.cartitem.transactional;

import com.ecommerce.davivienda.entity.cart.Cart;
import com.ecommerce.davivienda.entity.cart.CartItem;

import java.util.List;
import java.util.Optional;

/**
 * Servicio transaccional para operaciones de consulta y persistencia de CartItem.
 * Maneja todas las operaciones de acceso a datos de carritos y sus items.
 *
 * @author Team Ecommerce Davivienda
 * @since 1.0.0
 */
public interface CartItemTransactionalService {

    /**
     * Busca un carrito existente del usuario o crea uno nuevo.
     *
     * @param userRoleId ID del rol de usuario
     * @return Cart existente o nuevo carrito creado
     */
    Cart findOrCreateCart(Integer userRoleId);

    /**
     * Busca un CartItem por carrito y producto.
     *
     * @param cartId ID del carrito
     * @param productId ID del producto
     * @return Optional con el CartItem si existe
     */
    Optional<CartItem> findCartItemByCartAndProduct(Integer cartId, Integer productId);

    /**
     * Busca un CartItem por ID o lanza excepci√≥n.
     *
     * @param itemId ID del item
     * @return CartItem encontrado
     */
    CartItem findCartItemById(Integer itemId);

    /**
     * Verifica si existe un CartItem para el carrito y producto.
     *
     * @param cartId ID del carrito
     * @param productId ID del producto
     * @return true si existe, false en caso contrario
     */
    boolean existsCartItemByCartAndProduct(Integer cartId, Integer productId);

    /**
     * Obtiene todos los items de un carrito.
     *
     * @param cartId ID del carrito
     * @return Lista de CartItem del carrito
     */
    List<CartItem> findCartItemsByCartId(Integer cartId);

    /**
     * Guarda un CartItem.
     *
     * @param cartItem Item a guardar
     * @return CartItem guardado
     */
    CartItem saveCartItem(CartItem cartItem);

    /**
     * Elimina un CartItem.
     *
     * @param cartItem Item a eliminar
     */
    void deleteCartItem(CartItem cartItem);

    /**
     * Elimina todos los items de un carrito.
     *
     * @param cartId ID del carrito
     */
    void deleteCartItemsByCartId(Integer cartId);
}
```

### Ejemplo 2: Implementaci√≥n Transactional

```java
package com.ecommerce.davivienda.service.cartitem.transactional;

import com.ecommerce.davivienda.entity.cart.Cart;
import com.ecommerce.davivienda.entity.cart.CartItem;
import com.ecommerce.davivienda.exception.CartException;
import com.ecommerce.davivienda.repository.cart.CartItemRepository;
import com.ecommerce.davivienda.repository.cart.CartRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

import static com.ecommerce.davivienda.constants.Constants.CODE_CART_ITEM_NOT_FOUND;
import static com.ecommerce.davivienda.constants.Constants.ERROR_CART_ITEM_NOT_FOUND;

/**
 * Implementaci√≥n del servicio transaccional para operaciones de consulta y persistencia de CartItem.
 * Centraliza todas las operaciones de acceso a datos.
 *
 * @author Team Ecommerce Davivienda
 * @since 1.0.0
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class CartItemTransactionalServiceImpl implements CartItemTransactionalService {

    private final CartRepository cartRepository;
    private final CartItemRepository cartItemRepository;

    @Override
    @Transactional
    public Cart findOrCreateCart(Integer userRoleId) {
        log.debug("Buscando carrito para usuario {}", userRoleId);
        
        return cartRepository.findByUsuarioRolId(userRoleId)
                .orElseGet(() -> {
                    Cart newCart = Cart.builder()
                            .usuarioRolId(userRoleId)
                            .build();
                    Cart savedCart = cartRepository.save(newCart);
                    return savedCart;
                });
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<CartItem> findCartItemByCartAndProduct(Integer cartId, Integer productId) {
        log.debug("Buscando CartItem en carrito {} para producto {}", cartId, productId);
        return cartItemRepository.findByCartAndProduct(cartId, productId);
    }

    @Override
    @Transactional(readOnly = true)
    public CartItem findCartItemById(Integer itemId) {
        log.debug("Buscando CartItem con ID: {}", itemId);
        
        return cartItemRepository.findById(itemId)
                .orElseThrow(() -> new CartException(
                    ERROR_CART_ITEM_NOT_FOUND, 
                    CODE_CART_ITEM_NOT_FOUND
                ));
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsCartItemByCartAndProduct(Integer cartId, Integer productId) {
        log.debug("Verificando existencia de producto {} en carrito {}", productId, cartId);
        return cartItemRepository.existsByCartAndProduct(cartId, productId);
    }

    @Override
    @Transactional(readOnly = true)
    public List<CartItem> findCartItemsByCartId(Integer cartId) {
        log.debug("Obteniendo items del carrito {}", cartId);
        return cartItemRepository.findByCartCarritoId(cartId);
    }

    @Override
    @Transactional
    public CartItem saveCartItem(CartItem cartItem) {
        log.debug("Guardando CartItem en carrito {}", cartItem.getCart().getCarritoId());
        return cartItemRepository.save(cartItem);
    }

    @Override
    @Transactional
    public void deleteCartItem(CartItem cartItem) {
        log.debug("Eliminando CartItem con ID: {}", cartItem.getProductosCarritoId());
        cartItemRepository.delete(cartItem);
    }

    @Override
    @Transactional
    public void deleteCartItemsByCartId(Integer cartId) {
        log.debug("Eliminando todos los items del carrito {}", cartId);
        cartItemRepository.deleteByCartCarritoId(cartId);
    }
}
```

### Ejemplo 3: ServiceImpl Usando Capacidad Transactional

**‚ùå ANTES - Acceso directo a repositories**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class CartItemServiceImpl implements CartItemService {

    private final CartItemRepository cartItemRepository;  // ‚ùå Inyecci√≥n directa
    private final CartRepository cartRepository;          // ‚ùå Inyecci√≥n directa
    private final CartItemValidationService validationService;
    private final CartItemBuilderService builderService;

    @Override
    @Transactional
    public CartItemResponseDto addItemToCart(CartItemRequestDto request) {
        // ‚ùå Acceso directo a repository
        Cart cart = cartRepository.findByUsuarioRolId(userRoleId)
                .orElseGet(() -> {
                    Cart newCart = Cart.builder()
                            .usuarioRolId(userRoleId)
                            .build();
                    return cartRepository.save(newCart);  // ‚ùå Save directo
                });

        // ‚ùå Acceso directo a repository
        CartItem cartItem = cartItemRepository.findByCartAndProduct(
                cart.getCarritoId(), request.getProductId())
                .orElse(null);

        // ‚ùå Save directo
        CartItem savedItem = cartItemRepository.save(cartItem);
        return cartItemMapper.toResponseDto(savedItem);
    }
}
```

**‚úÖ DESPU√âS - Delegaci√≥n a capacidad transactional**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class CartItemServiceImpl implements CartItemService {

    private final CartItemTransactionalService transactionalService;  // ‚úÖ Capacidad
    private final CartItemValidationService validationService;
    private final CartItemBuilderService builderService;
    private final CartItemMapper cartItemMapper;

    @Override
    @Transactional
    public CartItemResponseDto addItemToCart(CartItemRequestDto request) {
        Integer userRoleId = validationService.getUserRoleIdFromDocument(
                request.getDocumentType(), request.getDocumentNumber());
        
        validationService.validateUserHasClientRole(userRoleId);
        
        // ‚úÖ Delegaci√≥n a transactional
        Cart cart = transactionalService.findOrCreateCart(userRoleId);
        
        Product product = validationService.validateProductExists(request.getProductId());
        validationService.validateProductActive(product);
        validationService.validateQuantity(request.getQuantity());
        
        // ‚úÖ Delegaci√≥n a transactional
        CartItem cartItem = transactionalService.findCartItemByCartAndProduct(
                cart.getCarritoId(), request.getProductId())
                .orElse(null);
        
        if (cartItem != null) {
            Integer oldQuantity = cartItem.getCantidad();
            builderService.updateQuantity(cartItem, request.getQuantity());
            log.info("Producto {} actualizado de {} a {}", 
                    request.getProductId(), oldQuantity, request.getQuantity());
        } else {
            cartItem = builderService.buildCartItem(request, cart, product);
            log.info("Producto {} creado en carrito", request.getProductId());
        }
        
        // ‚úÖ Delegaci√≥n a transactional
        CartItem savedItem = transactionalService.saveCartItem(cartItem);
        
        return cartItemMapper.toResponseDto(savedItem);
    }

    @Override
    @Transactional(readOnly = true)
    public List<CartItemResponseDto> getCartItems(Integer cartId) {
        validationService.validateCartExists(cartId);
        
        // ‚úÖ Delegaci√≥n a transactional
        List<CartItem> items = transactionalService.findCartItemsByCartId(cartId);
        
        return cartItemMapper.toResponseDtoList(items);
    }

    @Override
    @Transactional
    public void removeItemFromCart(Integer itemId) {
        // ‚úÖ Delegaci√≥n a transactional
        CartItem cartItem = transactionalService.findCartItemById(itemId);
        transactionalService.deleteCartItem(cartItem);
        
        log.info("Item {} eliminado exitosamente", itemId);
    }
}
```

### Ejemplo 4: Operaci√≥n Compleja findOrCreate

```java
@Override
@Transactional
public Cart findOrCreateCart(Integer userRoleId) {
    log.debug("Buscando carrito para usuario {}", userRoleId);
    
    return cartRepository.findByUsuarioRolId(userRoleId)
            .orElseGet(() -> {
                // ‚úÖ Crear si no existe
                Cart newCart = Cart.builder()
                        .usuarioRolId(userRoleId)
                        .fechaCreacion(LocalDateTime.now())
                        .activo(true)
                        .build();
                
                Cart savedCart = cartRepository.save(newCart);
                log.debug("Carrito {} creado para usuario {}", 
                        savedCart.getCarritoId(), userRoleId);
                
                return savedCart;
            });
}
```

## üö´ Restricciones

1. **NO** inyectar repositories directamente en `ServiceImpl` (usar capacidad transactional)
2. **NO** crear operaciones de BD sin `@Transactional` o `@Transactional(readOnly = true)`
3. **NO** omitir interface `*TransactionalService`
4. **NO** crear capacidad transactional sin documentaci√≥n JavaDoc completa
5. **NO** usar `log.info()` en operaciones transactionales (usar `log.debug()`)
6. **NO** incluir l√≥gica de negocio en m√©todos transactionales (solo acceso a datos)
7. **NO** retornar null en m√©todos `find*OrThrow` (lanzar excepci√≥n)
8. **NO** mezclar operaciones de lectura y escritura sin anotar correctamente
9. **NO** crear m√©todos con nombres gen√©ricos (`getData()`, `process()`)
10. **NO** omitir logs debug en operaciones cr√≠ticas

## ‚úÖ Validaci√≥n Autom√°tica

Cursor debe detectar:

**Arquitectura:**
- ‚ùå `ServiceImpl` inyectando repositories (`*Repository`) directamente
- ‚ùå Llamadas a `repository.find*()`, `repository.save()`, `repository.delete()` desde `ServiceImpl`
- ‚ùå Capacidad transactional sin interface correspondiente
- ‚ùå M√©todos transactionales sin `@Transactional`

**Anotaciones:**
- ‚ùå M√©todos de consulta sin `@Transactional(readOnly = true)`
- ‚ùå M√©todos de escritura sin `@Transactional`
- ‚ùå Falta de `@Service` en implementaci√≥n
- ‚ùå Falta de `@RequiredArgsConstructor`

**Nomenclatura:**
- ‚ùå M√©todos sin prefijos est√°ndar (`find*`, `save*`, `delete*`, `exists*`)
- ‚ùå M√©todos con nombres gen√©ricos sin contexto
- ‚ùå Interface sin sufijo `TransactionalService`
- ‚ùå Implementaci√≥n sin sufijo `TransactionalServiceImpl`

**Logs:**
- ‚ùå Uso de `log.info()` en lugar de `log.debug()` en operaciones BD
- ‚ùå Logs excesivos que reducen legibilidad
- ‚ùå Falta de logs en operaciones de escritura cr√≠ticas

**JavaDoc:**
- ‚ùå M√©todos sin documentaci√≥n de par√°metros y retorno
- ‚ùå Interface sin JavaDoc de clase
- ‚ùå Falta de descripci√≥n de excepciones lanzadas

## üéØ Objetivo + Regla de Oro

**Objetivo**: Centralizar TODAS las operaciones de acceso a datos en una capacidad dedicada que separa claramente la l√≥gica de negocio del acceso a BD, facilitando testing y mantenimiento.

**REGLA DE ORO**: "TODA operaci√≥n de BD (find, save, delete, exists) en `transactional/`. ServiceImpl NUNCA inyecta repositories. Interface + Implementaci√≥n siempre. `@Transactional(readOnly = true)` para consultas, `@Transactional` para escritura. `log.debug()` en lugar de `log.info()`. Nomenclatura clara: `find*`, `save*`, `delete*`, `exists*`, `findOrCreate*`."

---

## üìä Comparativa Antes/Despu√©s

| Aspecto | Sin Transactional | Con Transactional |
|---|---|---|
| **Inyecciones en ServiceImpl** | 4+ repositories | 1 capacidad |
| **Responsabilidades** | Mixtas (negocio + BD) | Separadas |
| **Testing** | Dif√≠cil (mockear m√∫ltiples repos) | F√°cil (mockear 1 capacidad) |
| **Acoplamiento** | Alto (a implementaciones JPA) | Bajo (a interface) |
| **Reutilizaci√≥n** | Duplicaci√≥n entre servicios | M√©todos compartidos |
| **Mantenibilidad** | Cambios en BD afectan m√∫ltiples clases | Cambios en BD solo en transactional |

## üìã Checklist de Creaci√≥n

| Fase | Verificaci√≥n |
|---|---|
| **Dise√±o** | Interface + Implementaci√≥n ‚Ä¢ Ubicaci√≥n en `transactional/` ‚Ä¢ Nomenclatura correcta |
| **Interface** | JavaDoc completo ‚Ä¢ M√©todos con prop√≥sito claro ‚Ä¢ Par√°metros documentados |
| **Implementaci√≥n** | `@Service` + `@RequiredArgsConstructor` ‚Ä¢ Inyecci√≥n de repositories ‚Ä¢ Anotaciones `@Transactional` |
| **M√©todos Consulta** | `@Transactional(readOnly = true)` ‚Ä¢ `log.debug()` ‚Ä¢ Retornar Optional o lanzar excepci√≥n |
| **M√©todos Escritura** | `@Transactional` ‚Ä¢ `log.debug()` ‚Ä¢ Validaci√≥n de entrada |
| **Integraci√≥n** | ServiceImpl usa transactional ‚Ä¢ Sin inyecci√≥n directa de repositories ‚Ä¢ Tests actualizados |

## üîó Referencias

> Ver tambi√©n:
> - [servicios-01-creacion-servicios.mdc](./servicios-01-creacion-servicios.mdc) - Arquitectura en capas
> - [servicios-09-organizacion-capacidades.mdc](./servicios-09-organizacion-capacidades.mdc) - Organizaci√≥n por capacidades
> - [servicios-10-buenas-practicas.mdc](./servicios-10-buenas-practicas.mdc) - Clean Code y SRP

## üí° Beneficios Clave

| Beneficio | Impacto |
|---|---|
| **Alta Cohesi√≥n** | Todas las operaciones de BD en un lugar |
| **Bajo Acoplamiento** | ServiceImpl independiente de tecnolog√≠a de persistencia |
| **Single Responsibility** | Transactional solo acceso a datos, Service solo l√≥gica |
| **Testeable** | Mock de 1 capacidad vs m√∫ltiples repositories |
| **Mantenible** | Cambios en consultas no afectan l√≥gica de negocio |
| **Reutilizable** | M√©todos transactionales compartidos entre servicios |
| **Escalable** | Agregar operaciones BD sin tocar coordinador |
