---
description: Gu√≠a para crear servicios Spring con arquitectura en capas y principios SOLID
globs: ["**/service/**/*.java"]
alwaysApply: true
---

# üèóÔ∏è Creaci√≥n de Servicios - Arquitectura en Capas

## üìã TL;DR

- ‚úÖ **CR√çTICO**: Verificar DTOs/modelos/servicios existentes ANTES de crear - reutilizar sin modificar tipos/nombres
- ‚úÖ **OBLIGATORIO**: Solicitar URL, CURL y responses (√©xito + error) ANTES de crear servicio
- ‚úÖ **OBLIGATORIO**: TODO mapeo DTO ‚Üî Entidad en Mapper con MapStruct (NO Builder services, NO mapeo manual, NO ModelMapper)
- ‚úÖ **OBLIGATORIO**: Mapper maneja construcci√≥n (`toEntity()`), actualizaci√≥n (`updateEntity()`), y conversi√≥n (`toResponseDto()`)
- ‚úÖ **OBLIGATORIO**: Autenticar con `AuthUserService.getAuthenticatedUserRoleId()` (1 l√≠nea) y validar ownership EXCEPTO categor√≠as, tipos documento, productos, crear usuario
- ‚úÖ Arquitectura: Controller ‚Üí Service Principal ‚Üí External Service ‚Üí Feign Client ‚Ä¢ Inyecci√≥n por interfaz
- ‚úÖ Organizaci√≥n: Simple (1 op) / Organizada (‚â•2 ops) / Modular (m√≥dulo completo)
- ‚úÖ Servicios External en `service/{dominio}/external/` ‚Ä¢ Para ‚â•2 capacidades, ver regla 09

## üö® Reglas Principales

1. **Verificaci√≥n obligatoria**: Antes de crear, buscar DTOs/modelos/servicios/endpoints existentes en `dto/`, `documents/`, `models/`, `service/`. Reutilizar sin modificar tipos/nombres de campos (solo agregar nuevos). Preguntar al usuario sobre controller (nuevo o reutilizar).
2. **Validaci√≥n previa**: Solicitar URL, CURL y responses JSON (√©xito + error) ANTES de crear cualquier servicio. No inventar estructura de DTOs.
3. **Mapeo con MapStruct (OBLIGATORIO)**: TODO mapeo DTO ‚Üî Entidad debe hacerse en Mapper con MapStruct. Esto incluye: construcci√≥n de entidades (`toEntity()`), actualizaci√≥n de entidades (`updateEntity()` con `@MappingTarget`), y conversi√≥n a DTOs (`toResponseDto()`). NO crear servicios Builder separados para mapeo de DTOs. NO usar mapeo manual ni otras librer√≠as (ModelMapper, Dozer, BeanUtils).
4. **Arquitectura en capas**: Controller ‚Üí Service (Interface) ‚Üí Service Impl ‚Üí External Service ‚Üí Feign Client. Servicios External SIEMPRE en paquete `service/{dominio}/external/`.
5. **Inyecci√≥n de dependencias**: SIEMPRE por interfaz usando `@RequiredArgsConstructor` (NUNCA `@Autowired` ni implementaciones concretas).
6. **Organizaci√≥n por complejidad**: Simple (1 op) en `service/{dominio}/`, Organizada (‚â•2 ops) con subcarpetas `service/{dominio}/{operacion}/`, Modular (m√≥dulo completo) con paquetes en todas las capas.
7. **Autenticaci√≥n por Token con AuthUserService (OBLIGATORIO)**: TODAS las operaciones DEBEN usar `AuthUserService.getAuthenticatedUserRoleId()` para obtener el userRoleId del usuario autenticado (1 l√≠nea). EXCEPCIONES: Consulta de categor√≠as, tipos de documento, consulta/creaci√≥n de productos, creaci√≥n de usuarios.

## üìä Referencia R√°pida

### Tipos de Servicios

| Tipo | Sufijo | Responsabilidad | Ubicaci√≥n | Dependencias | Exposici√≥n |
|------|--------|----------------|-----------|--------------|------------|
| Principal | `ServiceImpl` | Coordinar flujo completo, validaciones de negocio | `service/{dominio}/` | Servicios External | ‚úÖ P√∫blica |
| External | `External*ServiceImpl` | Comunicaci√≥n con APIs externas | `service/{dominio}/external/` | Feign Clients | ‚ùå Interna |
| Especializado | `*ServiceImpl` | Tarea espec√≠fica del dominio | `service/{dominio}/` | Feign Clients, otros servicios | ‚úÖ P√∫blica |
| Processor | `*Processor` | Transformar/procesar datos | `service/{dominio}/` | Ninguna o DTOs | ‚ùå Interna |
| Organization | `*OrganizationService` | Ordenar/agrupar datos (uso interno) | `service/{dominio}/organization/` | Ninguna o DTOs | ‚ùå Interna |
| Retriever | `*RepositoryImpl` | Acceso a bases de datos | `service/{dominio}/` | JPA, MongoDB Repositories | ‚ùå Interna |

### Decisi√≥n de Controller y Exposici√≥n de APIs

**üî¥ CR√çTICO: SIEMPRE preguntar al usuario ANTES de crear o modificar controllers**

#### Pregunta 1: ¬øEl servicio debe ser expuesto p√∫blicamente?

| Tipo de Servicio | ¬øExponer API? | Acci√≥n |
|------------------|:-------------:|--------|
| Processor / Organization / Retriever | ‚ùå NO | Uso interno solamente - NO crear endpoint |
| Principal / Especializado | ‚ö†Ô∏è Preguntar | "¬øDeseas exponer esta funcionalidad como API REST?" |

**Servicios que NO deben exponerse:**
- ‚úÖ Servicios de procesamiento/transformaci√≥n de datos (`*Processor`, `*OrganizationService`)
- ‚úÖ Servicios de acceso a datos (`*Repository`, `*Retriever`)
- ‚úÖ Servicios auxiliares que son usados por otros servicios internamente

**Servicios que pueden exponerse (previa aprobaci√≥n):**
- ‚ö†Ô∏è Servicios principales que coordinan flujos de negocio
- ‚ö†Ô∏è Servicios especializados con funcionalidad espec√≠fica del dominio

#### Pregunta 2: Si el usuario aprueba exponer, ¬ønuevo controller o reutilizar?

| Pregunta | Opci√≥n A | Opci√≥n B |
|----------|----------|----------|
| "¬øDeseas crear un **nuevo controller** o **reutilizar uno existente**?" | Crear nuevo controller separado | Agregar endpoint a controller existente |

**Criterios para crear nuevo controller:**
- ‚úÖ Funcionalidad completamente independiente del dominio existente
- ‚úÖ Requiere ruta base diferente (ej: `/api/v1/declaracion-asegurabilidad` vs `/api/v1/oferta`)
- ‚úÖ Endpoints relacionados a un m√≥dulo espec√≠fico
- ‚úÖ Documentaci√≥n Swagger diferenciada

**Criterios para reutilizar controller existente:**
- ‚úÖ Endpoints relacionados al mismo dominio
- ‚úÖ Comparten ruta base com√∫n
- ‚úÖ Operaciones sobre la misma entidad principal

### Estructura de Carpetas

| Caso | Estructura | Cu√°ndo usar | Ejemplo |
|------|-----------|-------------|---------|
| **Simple** | `service/{dominio}/` | Una funcionalidad, DTOs compartidos | `service/shorturl/` |
| **Organizada** | `service/{dominio}/{operacion}/` | ‚â•2 ops HTTP diferentes | `service/transaction/detail/` + `step/` |
| **Modular** ‚≠ê | `service/{modulo}/` + paquetes en todas capas | M√≥dulo completo independiente | `service/processconfig/` + `controller/processconfig/` + `exception/processconfig/` |
| **Interna** | `service/{dominio}/organization/` | Servicios de procesamiento/organizaci√≥n (NO expuestos) | `service/insurability/organization/` |

**Criterios para Estructura Modular:**

| Criterio | Simple | Organizada | Modular |
|----------|:------:|:----------:|:-------:|
| 1 operaci√≥n | ‚úÖ | ‚ùå | ‚ùå |
| ‚â•2 ops misma entidad | ‚ùå | ‚úÖ | ‚ùå |
| M√≥dulo completo (controller + service + dto + exception) | ‚ùå | ‚ùå | ‚úÖ |
| Con README.md propio | ‚ùå | ‚ùå | ‚úÖ |

### Validaci√≥n de DTOs/Modelos/Servicios/Endpoints Existentes

**‚ö†Ô∏è CR√çTICO**: Verificar existentes ANTES de crear nuevos

| Tipo | D√≥nde buscar | Ejemplo |
|------|-------------|---------|
| DTOs | `dto/{dominio}/` | `dto/processconfig/` |
| Documentos | `documents/` | `documents/allies/WorkFlowAlly` |
| Modelos | `models/` | `models/Response` |
| Servicios | `service/` | `TransactionService` para tracking |
| Endpoints | `service/**/external/` | Feign Clients con `@PathVariable` |

**Regla de Reutilizaci√≥n:**
- ‚úÖ Existe ‚Üí Reutilizar y agregar SOLO campos faltantes
- ‚úÖ Endpoint con path variable ‚Üí Pasar par√°metro din√°mico
- ‚ùå Solo crear nuevo si NO existe alternativa

**üö´ PROHIBIDO al reutilizar DTOs/Modelos:**
- ‚ùå **NO cambiar tipos de datos** de campos existentes (ej: `boolean` ‚Üí `Boolean`)
- ‚ùå **NO cambiar nombres** de campos existentes
- ‚ùå **NO cambiar anotaciones** existentes (`@JsonProperty`, `@Field`)
- ‚ùå **NO modificar JavaDoc** de campos existentes
- ‚úÖ **SOLO agregar** campos nuevos al final

**Beneficios:** ~100-200 l√≠neas menos, sin mapeos, mantenimiento √∫nico

### Arquitectura con Servicios External

**Patr√≥n completo para consumir APIs externas:**

```
controller/
‚îî‚îÄ‚îÄ {Dominio}Controller.java
    ‚Üì inyecta
service/{dominio}/
‚îú‚îÄ‚îÄ {Dominio}Service.java (Interface)
‚îú‚îÄ‚îÄ {Dominio}ServiceImpl.java (Principal)
‚îÇ   ‚Üì inyecta
‚îî‚îÄ‚îÄ external/
    ‚îú‚îÄ‚îÄ External{Servicio}Client.java (Feign)
    ‚îú‚îÄ‚îÄ External{Servicio}Service.java (Interface)
    ‚îî‚îÄ‚îÄ External{Servicio}ServiceImpl.java (Implementaci√≥n)
```

**Flujo de responsabilidades:**
1. **Controller**: Recibe request, valida entrada, delega a servicio principal (‚ö†Ô∏è SOLO si el usuario aprob√≥ exponer la API)
2. **Servicio Principal**: Coordina operaciones, aplica reglas de negocio, valida respuestas
3. **Servicio External**: Maneja comunicaci√≥n con API externa, valida respuestas t√©cnicas
4. **Feign Client**: Define contrato de API externa
5. **Servicio Organization** (opcional): Procesa/organiza datos internamente - NO expuesto en controller

> **Nota**: Si hay ‚â•2 capacidades en `external/` (ej: auth + questions), organizar en subcarpetas por capacidad.  
> Ver [servicios-09-organizacion-capacidades.mdc](./servicios-09-organizacion-capacidades.mdc) para detalles.

### Mapeo con MapStruct (OBLIGATORIO)

| Aspecto | Convenci√≥n | Ejemplo |
|---|---|---|
| Ubicaci√≥n | `mapper/{dominio}/` | `mapper/cart/CartItemMapper.java` |
| Anotaci√≥n | `@Mapper(componentModel = "spring")` | Inyecci√≥n autom√°tica |
| Nomenclatura | `{Dominio}Mapper` | `UserMapper`, `CartItemMapper` |
| M√©todos Construcci√≥n | `toEntity()` con par√°metros m√∫ltiples | `toEntity(requestDto, cart, product)` |
| M√©todos Actualizaci√≥n | `updateEntity()` con `@MappingTarget` | `updateQuantity(@MappingTarget item, qty)` |
| M√©todos Conversi√≥n | `toResponseDto()`, `toDto()` | `toResponseDto(entity)` |
| Inyecci√≥n | Por interfaz en servicios | `private final CartItemMapper mapper;` |

**üö´ PROHIBIDO: NO crear servicios Builder para mapeo de DTOs**
- ‚ùå `CartItemBuilderService` con `buildCartItem(dto, cart, product)` ‚Üí Usar `mapper.toEntity(dto, cart, product)`
- ‚ùå `UserBuilderService` con `buildUserFromRequest(dto)` ‚Üí Usar `mapper.toEntity(dto)`
- ‚ùå Servicios con m√©todos `update*Fields()` para actualizar entidades ‚Üí Usar `mapper.updateEntity(dto, entity)`

**‚úÖ CORRECTO: Mapper con MapStruct maneja TODO el mapeo**
```java
@Mapper(componentModel = "spring")
public interface CartItemMapper {
    // ‚úÖ Construcci√≥n con m√∫ltiples par√°metros
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "cart", source = "cart")
    @Mapping(target = "product", source = "product")
    @Mapping(target = "cantidad", source = "request.quantity")
    CartItem toEntity(CartItemRequestDto request, Cart cart, Product product);
    
    // ‚úÖ Actualizaci√≥n con @MappingTarget
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "cart", ignore = true)
    @Mapping(target = "product", ignore = true)
    void updateQuantity(@MappingTarget CartItem item, Integer newQuantity);
    
    // ‚úÖ Conversi√≥n a DTO
    CartItemResponseDto toResponseDto(CartItem item);
}
```

**Beneficios de MapStruct:**
- ‚úÖ Mapeo compile-time (sin reflexi√≥n)
- ‚úÖ Type-safe y r√°pido
- ‚úÖ C√≥digo generado autom√°ticamente
- ‚úÖ Reemplaza servicios Builder para mapeo (menos clases)
- ‚úÖ F√°cil de testear y mantener
- ‚úÖ Manejo autom√°tico de campos con mismo nombre
- ‚úÖ Soporte para mapeo con m√∫ltiples par√°metros
- ‚úÖ Actualizaci√≥n in-place con `@MappingTarget`

### Autenticaci√≥n por Token (OBLIGATORIO)

**‚úÖ Usar `AuthUserService` - Servicio Gen√©rico de Autenticaci√≥n**

| Aspecto | Detalle |
|---------|---------|
| **Ubicaci√≥n** | `service/auth/AuthUserService` |
| **Responsabilidad** | Extraer email del token JWT, obtener userRoleId y validar rol de Cliente |
| **Reutilizable** | ‚úÖ S√ç - En todos los m√≥dulos del sistema (cart, order, payment, etc.) |
| **Inyecci√≥n** | `private final AuthUserService authUserService;` |

**Patr√≥n recomendado (con AuthUserService):**

```java
@Service
@RequiredArgsConstructor
public class CartItemServiceImpl implements CartItemService {
    private final AuthUserService authUserService;  // ‚úÖ Servicio gen√©rico
    
    @Override
    @Transactional
    public CartItemResponseDto addItemToCart(CartItemRequestDto request) {
        Integer userRoleId = authUserService.getAuthenticatedUserRoleId();  // ‚úÖ Una l√≠nea
        // ... l√≥gica de negocio
    }
}
```

**Patr√≥n alternativo (manual - solo si AuthUserService no cubre el caso de uso):**

```java
String userEmail = authenticatedUserUtil.getCurrentUsername();
Integer userRoleId = validationService.getUserRoleIdFromEmail(userEmail);
validationService.validateUserHasClientRole(userRoleId);
```

**¬øPor qu√© usar `AuthUserService`?**
- ‚úÖ **Centralizado**: L√≥gica de autenticaci√≥n en un solo lugar
- ‚úÖ **Reutilizable**: Disponible para todos los m√≥dulos
- ‚úÖ **Consistente**: Mismo comportamiento en todo el sistema
- ‚úÖ **Mantenible**: Cambios en autenticaci√≥n solo en un servicio
- ‚úÖ **Testeable**: F√°cil de mockear en tests unitarios
- ‚úÖ **Menos c√≥digo**: 1 l√≠nea vs 3 l√≠neas

**Tabla de decisi√≥n - ¬øRequiere autenticaci√≥n por token?**

| Operaci√≥n | ¬øRequiere Token? | Raz√≥n |
|-----------|:----------------:|-------|
| **Listar categor√≠as** | ‚ùå NO | Informaci√≥n p√∫blica del cat√°logo |
| **Listar tipos de documento** | ‚ùå NO | Informaci√≥n p√∫blica necesaria para registro |
| **Consultar productos** | ‚ùå NO | Cat√°logo p√∫blico de productos |
| **Crear producto** | ‚ùå NO | Operaci√≥n administrativa (protegida por otro mecanismo) |
| **Crear usuario** | ‚ùå NO | Registro inicial de usuario (sin token previo) |
| **Login** | ‚ùå NO | Generaci√≥n del token (sin token previo) |
| **Agregar item al carrito** | ‚úÖ S√ç | Operaci√≥n espec√≠fica del usuario |
| **Actualizar item del carrito** | ‚úÖ S√ç | Operaci√≥n espec√≠fica del usuario |
| **Eliminar item del carrito** | ‚úÖ S√ç | Operaci√≥n espec√≠fica del usuario |
| **Ver mi carrito** | ‚úÖ S√ç | Informaci√≥n privada del usuario |
| **Ver mis pedidos** | ‚úÖ S√ç | Informaci√≥n privada del usuario |
| **Actualizar mi perfil** | ‚úÖ S√ç | Informaci√≥n privada del usuario |
| **Cambiar mi contrase√±a** | ‚úÖ S√ç | Operaci√≥n de seguridad del usuario |

**Validaciones adicionales seg√∫n tipo de operaci√≥n:**

| Tipo Operaci√≥n | Validaciones Requeridas | Ejemplo |
|----------------|------------------------|---------|
| **Consulta propia** | Email desde token | Ver mi carrito, mis pedidos |
| **Modificaci√≥n propia** | Email desde token + verificar ownership | Actualizar item de MI carrito |
| **Eliminaci√≥n propia** | Email desde token + verificar ownership | Eliminar item de MI carrito |
| **Operaci√≥n sobre recurso** | Email desde token + validar que recurso pertenece al usuario | `validateItemBelongsToUser(itemId, userRoleId)` |

**Flujo est√°ndar con validaci√≥n de ownership:**

```
1. Extraer email del token JWT
    ‚Üì
2. Obtener userRoleId desde email
    ‚Üì
3. Validar rol de Cliente (si aplica)
    ‚Üì
4. Validar que el recurso pertenece al usuario
    ‚Üì
5. Ejecutar operaci√≥n
```

## ‚úÖ Ejemplos

### Ejemplo 1: Arquitectura Completa con Servicio External

**Controller (SOLO si usuario aprueba exposici√≥n):**
```java
@RestController
@RequestMapping("/api/v1/declaracion-asegurabilidad")
@RequiredArgsConstructor
public class InsurabilityController {
    private final InsurabilityService insurabilityService;

    @PostMapping("/preguntas")
    public InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            @RequestHeader("Authorization") String authorization,
            @Valid @RequestBody InsurabilityQuestionsRequestDto request) {
        return insurabilityService.getInsurabilityQuestions(request, authorization);
    }
}
```

**Servicio Principal (coordina y valida negocio):**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class InsurabilityServiceImpl implements InsurabilityService {
    private final ExternalInsurabilityQuestionsService externalInsurabilityQuestionsService;

    @Override
    public InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            InsurabilityQuestionsRequestDto request, String authorization) {
        // 1. Validar entrada
        if (authorization == null || authorization.trim().isEmpty()) {
            throw new ParametersException("Token requerido", CODE_AUTH_REQUIRED);
        }
        // 2. Delegar a servicio external
        InsurabilityQuestionsResponseDto response = 
            externalInsurabilityQuestionsService.getInsurabilityQuestions(request, authorization);
        // 3. Validar respuesta de negocio
        if (!response.isSuccess()) {
            throw new ParametersException("Error: " + response.getMessage(), CODE_ERROR);
        }
        return response;
    }
}
```

**Servicio External (service/insurability/external/):**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ExternalInsurabilityQuestionsServiceImpl 
        implements ExternalInsurabilityQuestionsService {
    private final ExternalInsurabilityQuestionsClient client;

    @Override
    public InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            InsurabilityQuestionsRequestDto request, String authorization) {
        try {
            InsurabilityQuestionsResponseDto response = client.getInsurabilityQuestions(authorization, request);
            if (response == null) throw new ParametersException("Respuesta nula", CODE_NULL_RESPONSE);
            return response;
        } catch (ParametersException e) {
            throw e;
        } catch (Exception e) {
            throw new ParametersException("Error externo: " + e.getMessage(), CODE_EXTERNAL_ERROR, e);
        }
    }
}
```

**Feign Client (service/insurability/external/):**
```java
@FeignClient(name = "insurability-questions-client", url = "${domain.gestor.url}")
public interface ExternalInsurabilityQuestionsClient {
    @PostMapping("${domain.gestor.endpoints.insurability-questions}")
    InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            @RequestHeader("Authorization") String authorization,
            @RequestBody InsurabilityQuestionsRequestDto request);
}
```

### Ejemplo 2: Servicio que Coordina M√∫ltiples Servicios

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ShortUrlServiceImpl implements ShortUrlService {
    private final ShortUrlParameterResolutionService parameterService;
    private final ExternalUrlShortenerService externalService;

    @Override
    public ShortUrlResponse shortenUrl(ShortUrlRequest request) {
        // 1. Resolver par√°metros ‚Üí 2. Acortar URL ‚Üí 3. Construir respuesta
        ResolvedShortUrlParametersDto params = parameterService.resolveParameters(request);
        String urlCorta = externalService.shortenUrl(request.longURL(), params.idSistemaOrigen(), params.diasVigencia());
        return new ShortUrlResponse(request.longURL(), urlCorta, params.diasVigencia());
    }
}
```


### Ejemplo 3: Reutilizaci√≥n (CR√çTICO)

| Elemento | ‚ùå Crear nuevo | ‚úÖ Reutilizar existente |
|----------|--------------|------------------------|
| **Endpoint** | Duplicar m√©todo | `parameterClient.consultChannelParameters("recortarUrl")` |
| **DTO** | Nuevo archivo | Agregar campos al DTO existente (NO modificar tipos) |
| **Servicio** | Nueva clase | `transactionService.saveTransactionStep(id, "paso", dto)` |

**Beneficios**: ~100-200 l√≠neas menos, sin mapeos, mantenimiento √∫nico

### Ejemplo 4: Servicio Organization (Uso Interno)

**Ubicaci√≥n**: `service/insurability/organization/`

```java
@Slf4j
@Service
public class InsurabilityQuestionsOrganizationServiceImpl 
        implements InsurabilityQuestionsOrganizationService {

    @Override
    public Map<Integer, List<InsurabilityQuestionDto>> groupQuestionsByParentIdAscending(
            List<InsurabilityQuestionDto> questions) {
        if (questions == null || questions.isEmpty()) return Collections.emptyMap();

        Map<Integer, List<InsurabilityQuestionDto>> grouped = questions.stream()
                .collect(Collectors.groupingBy(q -> q.getParentQuestionId() != null ? q.getParentQuestionId() : 0));
        grouped.forEach((parentId, list) -> list.sort(Comparator.comparing(q -> q.getOrder() != null ? q.getOrder() : Integer.MAX_VALUE)));
        return grouped;
    }
}
```

**Caracter√≠sticas:**
- ‚úÖ Uso INTERNO - NO exponer sin aprobaci√≥n del usuario
- ‚úÖ Sin DTOs propios (reutiliza DTOs existentes)
- ‚úÖ Sin Feign Clients
- ‚ö†Ô∏è Si usuario solicita exponer ‚Üí PREGUNTAR antes de crear endpoint

### Ejemplo 5: MapStruct vs Builder Services

| Aspecto | ‚ùå Builder Service | ‚úÖ MapStruct Mapper |
|---|---|---|
| **Archivos** | 2 (Interface + Impl) | 1 (Solo Mapper) |
| **M√©todos** | `buildEntity()`, `updateEntity()` | `toEntity()`, `updateEntity()` con `@MappingTarget` |
| **Type-safety** | ‚ùå Sin validaci√≥n compile-time | ‚úÖ Validaci√≥n compile-time |
| **Inyecciones** | Builder + Mapper | Solo Mapper |
| **Mantenibilidad** | Actualizar en 2 lugares | Actualizar solo Mapper |

> Ver tabla "Mapeo con MapStruct (OBLIGATORIO)" en Referencia R√°pida para estructura completa

### Ejemplo 5.1: Caso Real - UserBuilderService ‚Üí UserMapper

**Caso:** M√≥dulo User con Builder Service separado ‚Üí Consolidaci√≥n en Mapper

| M√©trica | Antes | Despu√©s | Mejora |
|---|---|---|---|
| Archivos | 4 (2 Builder + 2 Mapper) | 2 (Solo Mapper) | -50% |
| L√≠neas Builder | 129 l√≠neas | 0 (consolidado) | -100% |
| L√≠neas Mapper | 50 l√≠neas | 123 l√≠neas | +73 netas |
| Inyecciones | 5 dependencias | 4 dependencias | -20% |
| Type-safety | ‚ùå Manual | ‚úÖ Compile-time | ‚úÖ |

**Lecciones:**
- Builder Services para mapeo DTO ‚Üí Entidad violan arquitectura
- Tener Builder + Mapper crea redundancia y confusi√≥n
- MapStruct maneja construcci√≥n, actualizaci√≥n y conversi√≥n en un lugar
- M√©todos `default` en Mapper permiten l√≥gica compleja

### Ejemplo 6: Autenticaci√≥n con AuthUserService

| Escenario | C√≥digo | Validaci√≥n |
|---|---|---|
| **‚úÖ Con AuthUserService** | `Integer userRoleId = authUserService.getAuthenticatedUserRoleId();` | 1 l√≠nea |
| **‚ö†Ô∏è Manual (fallback)** | `String email = util.getCurrentUsername();`<br>`Integer id = validation.getUserRoleIdFromEmail(email);`<br>`validation.validateUserHasClientRole(id);` | 3 l√≠neas |

**Beneficios AuthUserService:**
- 1 l√≠nea vs 3 l√≠neas ‚Ä¢ Sin duplicaci√≥n ‚Ä¢ Centralizado ‚Ä¢ Reutilizable ‚Ä¢ Testeable

| Operaci√≥n | ¬øToken? | Validaciones |
|---|:---:|---|
| Agregar al carrito | ‚úÖ | Auth + Ownership |
| Categor√≠as/Productos | ‚ùå | P√∫blico |
| Crear usuario | ‚ùå | Registro inicial |

> Ver tabla "Autenticaci√≥n por Token (OBLIGATORIO)" en Referencia R√°pida para casos completos

## üö´ Restricciones

1. **NO** crear DTOs/modelos/servicios sin verificar existentes en `dto/`, `documents/`, `models/`, `service/`
2. **NO** modificar tipos de datos ni nombres de campos existentes al reutilizar (solo agregar nuevos)
3. **NO** crear servicios sin URL, CURL y responses JSON reales (no inventar estructura)
4. **NO** usar mapeo manual entre DTOs y entidades (usar MapStruct obligatoriamente)
5. **NO** crear servicios Builder (`*BuilderService`) para mapeo de DTOs (usar Mapper con MapStruct)
6. **NO** crear m√©todos `build*()` o `update*Fields()` en servicios separados (usar `mapper.toEntity()` y `mapper.updateEntity()`)
7. **NO** usar otras librer√≠as de mapeo (ModelMapper, Dozer, BeanUtils) en lugar de MapStruct
8. **NO** crear mappers sin `@Mapper(componentModel = "spring")`
9. **NO** colocar mappers fuera del paquete `mapper/{dominio}/`
10. **NO** inyectar implementaciones (`*ServiceImpl`) ni usar `@Autowired` (usar interfaces + `@RequiredArgsConstructor`)
11. **NO** llamar Feign Clients directamente desde servicios principales (usar servicio External en `external/`)
12. **NO** crear o modificar controllers sin preguntar PRIMERO al usuario si desea exponer la API
13. **NO** exponer servicios de procesamiento/organizaci√≥n sin aprobaci√≥n expl√≠cita del usuario
14. **NO** crear servicios sin interfaz correspondiente
15. **NO** hardcodear mensajes de error (usar constantes en `Constants.java`)
16. **NO** usar nomenclatura inconsistente (`premiumcalculation` vs `premiumCalculation` - usar camelCase)
17. **NO** crear servicios external fuera del paquete `service/{dominio}/external/`
18. **NO** crear servicios de organizaci√≥n/procesamiento fuera del paquete `service/{dominio}/organization/`
19. **NO** omitir autenticaci√≥n por token en operaciones que manipulan datos del usuario (excepto categor√≠as, tipos de documento, consulta/creaci√≥n de productos, creaci√≥n de usuarios) - USAR `AuthUserService.getAuthenticatedUserRoleId()`
20. **NO** usar patr√≥n manual de autenticaci√≥n (3 l√≠neas) cuando se puede usar `AuthUserService` (1 l√≠nea)
21. **NO** obtener userRoleId desde el request cuando est√° disponible en el token JWT
22. **NO** omitir validaci√≥n de ownership en operaciones de actualizaci√≥n/eliminaci√≥n de recursos del usuario

## ‚úÖ Validaci√≥n Autom√°tica

Cursor debe detectar:

- ‚ùå Creaci√≥n sin verificar DTOs/modelos/servicios existentes
- ‚ùå Modificaci√≥n de tipos de datos (`boolean` ‚Üí `Boolean`) o nombres de campos existentes
- ‚ùå Creaci√≥n de servicios sin URL, CURL y responses JSON
- ‚ùå Mapeo manual entre DTOs y entidades (uso de `new Entity()` con m√∫ltiples setters)
- ‚ùå **Servicios Builder (`*BuilderService`, `*BuilderServiceImpl`) que hacen mapeo de DTOs**
- ‚ùå **M√©todos `build*()` o `update*Fields()` en servicios que deber√≠an estar en Mapper**
- ‚ùå **Inyecci√≥n de Builder services junto con Mapper en el mismo servicio**
- ‚ùå Uso de `ModelMapper`, `Dozer`, `BeanUtils.copyProperties()` en lugar de MapStruct
- ‚ùå Mappers sin anotaci√≥n `@Mapper(componentModel = "spring")`
- ‚ùå Mappers ubicados fuera del paquete `mapper/{dominio}/`
- ‚ùå Servicios sin inyecci√≥n de mapper cuando hay conversiones DTO ‚Üî Entidad
- ‚ùå Creaci√≥n o modificaci√≥n de controller sin preguntar PRIMERO al usuario
- ‚ùå Exposici√≥n autom√°tica de servicios de procesamiento/organizaci√≥n sin aprobaci√≥n
- ‚ùå Inyecci√≥n de implementaciones (`*ServiceImpl`) en lugar de interfaces
- ‚ùå Servicios external fuera del paquete `external/`
- ‚ùå Servicios de organizaci√≥n fuera del paquete `organization/`
- ‚ùå Servicios sin `@Service`, `@Slf4j` o interfaz
- ‚ùå Uso de `@Autowired` en lugar de constructor
- ‚ùå Nomenclatura inconsistente (`premiumcalculation` vs `premiumCalculation`)
- ‚ùå Llamadas directas a Feign Clients desde servicios principales
- ‚ùå Estructura inventada de DTOs o campos "TODO"
- ‚ùå Operaciones de usuario sin usar `AuthUserService.getAuthenticatedUserRoleId()` (excepto categor√≠as, tipos documento, productos, crear usuario)
- ‚ùå Uso de patr√≥n manual de autenticaci√≥n (3 l√≠neas con `authenticatedUserUtil` + `validationService`) en lugar de `AuthUserService` (1 l√≠nea)
- ‚ùå UserRoleId obtenido desde request en lugar del token JWT
- ‚ùå Operaciones de actualizaci√≥n/eliminaci√≥n sin validar ownership del recurso
- ‚ùå Falta de inyecci√≥n de `AuthUserService` en servicios que manipulan datos de usuario
- ‚ùå M√©todos de validaci√≥n de ownership no implementados en servicios de validaci√≥n

## üéØ Objetivo + Regla de Oro

**Objetivo**: Crear servicios mantenibles, testables y que cumplan principios SOLID con arquitectura en capas clara.

**REGLA DE ORO**: "PRIMERO verificar existentes (dto/, documents/, models/, service/), LUEGO solicitar URL + CURL + responses, DESPU√âS preguntar si desea exponer API (servicios de procesamiento/organizaci√≥n son internos por defecto), FINALMENTE preguntar sobre controller (nuevo vs reutilizar). Reutilizar sin modificar tipos/nombres. Arquitectura: Controller (solo si aprobado) ‚Üí Service ‚Üí External (en external/) / Organization (en organization/) ‚Üí Feign. **TODO mapeo DTO ‚Üî Entidad en Mapper con MapStruct** (construcci√≥n `toEntity()`, actualizaci√≥n `updateEntity()`, conversi√≥n `toResponseDto()`) - **NO crear Builder services para mapeo**. SIEMPRE autenticar por token JWT usando `AuthUserService.getAuthenticatedUserRoleId()` (1 l√≠nea) y validar ownership en operaciones de usuario (EXCEPTO categor√≠as, tipos documento, productos, crear usuario). Una responsabilidad por servicio. Interfaces siempre."


> **Ver tambi√©n**: 
> - [servicios-02-feign-client.mdc](./servicios-02-feign-client.mdc) - Feign Clients
> - [servicios-03-feign-config.mdc](./servicios-03-feign-config.mdc) - Configuraci√≥n Feign
> - [servicios-04-excepciones.mdc](./servicios-04-excepciones.mdc) - Excepciones
> - [servicios-05-dtos.mdc](./servicios-05-dtos.mdc) - DTOs
> - [servicios-09-organizacion-capacidades.mdc](./servicios-09-organizacion-capacidades.mdc) - Organizaci√≥n por capacidades
