---
description: Est√°ndares SonarQube - Complejidad cognitiva y code smells en servicios
globs: ["**/service/**/*.java", "**/controller/**/*.java"]
alwaysApply: false
---

# üîç Calidad de C√≥digo - SonarQube en Servicios

## üìã TL;DR

- ‚úÖ Complejidad cognitiva ‚â§ 15 por m√©todo (ideal ‚â§ 10)
- ‚úÖ Extraer m√©todos privados para reducir complejidad
- ‚úÖ Usar `Objects::nonNull` en lugar de lambdas expl√≠citas
- ‚úÖ NO inicializar variables a `null` innecesariamente
- ‚ùå NO m√©todos > 50 l√≠neas

## üö® Reglas Principales

1. **Complejidad Cognitiva**: M√°ximo 15 por m√©todo (ideal ‚â§ 10). Extraer l√≥gica a m√©todos privados con nombres descriptivos
2. **M√©todos Cortos**: M√°ximo 50 l√≠neas. Si excede, refactorizar en m√©todos m√°s peque√±os
3. **Code Smells**: Eliminar trailing whitespace, inicializaciones innecesarias, y usar method references
4. **Separaci√≥n de Responsabilidades**: Cada m√©todo debe tener UNA sola responsabilidad clara
5. **Nombres Descriptivos**: M√©todos privados con nombres como `shouldReturnEmptyList()`, `extractAllowedPlans()`

## üìä Referencia R√°pida - Problemas Comunes

| Problema | Severidad | Soluci√≥n | Ejemplo |
|----------|-----------|----------|---------|
| **Complejidad Cognitiva Alta** | Critical | Extraer m√©todos privados | Ver Ejemplo 1 |
| **M√©todos largos** | Major | Dividir en subm√©todos | Ver Ejemplo 1 |
| **Trailing whitespace** | Minor | Eliminar espacios al final | `// comentario‚ê£` ‚Üí `// comentario` |
| **Inicializaci√≥n a null** | Minor | Usar m√©todo que retorna valor | `List x = null; if(...) x = y;` ‚Üí `extractList()` |
| **Lambda expl√≠cito** | Info | Usar method reference | `.filter(x -> x != null)` ‚Üí `.filter(Objects::nonNull)` |
| **Return early anidado** | Major | Extraer validaciones | Ver Ejemplo 2 |
| **Duplicaci√≥n de c√≥digo** | Major | Extraer m√©todo com√∫n | M√©todo reutilizable |

## ‚úÖ Ejemplos

### Ejemplo 1: Reducir Complejidad Cognitiva

**‚ùå ANTES: Complejidad Alta (10+)**
```java
public List<PlanDto> filterPlans(List<PlanDto> plans, ConfigDto config) {
    log.info("Iniciando filtrado. Planes: {}", plans.size());
    
    // M√∫ltiples validaciones anidadas + l√≥gica de extracci√≥n
    if (plans == null || plans.isEmpty()) {
        log.warn("Sin planes");
        return Collections.emptyList();
    }
    if (config == null || !config.isSuccess()) { /* ... */ }
    
    List<String> allowedCodes = null;
    if (config.getBody() != null && config.getBody().hasControls()) {
        allowedCodes = config.getBody().getCodes();
    }
    // ... m√°s validaciones y transformaciones anidadas (40 l√≠neas)
}
```

**‚úÖ DESPU√âS: Complejidad Reducida (3)**
```java
public List<PlanDto> filterPlans(List<PlanDto> plans, ConfigDto config) {
    log.info("Iniciando filtrado. Planes: {}", plans != null ? plans.size() : 0);
    
    if (shouldReturnEmptyList(plans)) {
        return Collections.emptyList();
    }
    if (shouldReturnAllPlans(config)) {
        return plans;
    }
    
    Set<Integer> allowedCodesInt = extractAllowedCodes(config);
    return allowedCodesInt.isEmpty() ? plans : applyPlanFilter(plans, allowedCodesInt);
}

// ‚úÖ M√©todos helper privados con responsabilidades √∫nicas
private boolean shouldReturnEmptyList(List<PlanDto> plans) { /* validaci√≥n */ }
private boolean shouldReturnAllPlans(ConfigDto config) { /* validaci√≥n */ }
private Set<Integer> extractAllowedCodes(ConfigDto config) { /* extracci√≥n */ }
private Set<Integer> convertStringCodesToInteger(List<String> codes) { 
    return codes.stream()
        .filter(Objects::nonNull)  // ‚úÖ Method reference
        .map(String::trim)
        .map(this::parseCode)
        .collect(Collectors.toSet());
}
private List<PlanDto> applyPlanFilter(List<PlanDto> plans, Set<Integer> codes) { /* filtrado */ }
```

**Resultados:**
- Complejidad cognitiva: 10+ ‚Üí 3
- M√©todo principal: 50 l√≠neas ‚Üí 15 l√≠neas
- Testabilidad: Cada m√©todo testeable independientemente
- Legibilidad: Auto-documentado con nombres descriptivos

### Ejemplo 2: Eliminar Code Smells

**‚ùå ANTES: M√∫ltiples Code Smells**
```java
private Set<Integer> convertCodes(List<String> codes) {
    return codes.stream()
        .filter(code -> code != null && !code.trim().isEmpty())  
        .map(String::trim)
        .map(this::parse)
        .filter(code -> code != null)  // ‚ùå Lambda expl√≠cito
        .collect(Collectors.toSet());
}

public void processData(String id) {
    List<DataDto> data = null;  // ‚ùå Inicializaci√≥n innecesaria
    if (id != null) {
        data = repository.findById(id);
    }
    // ... m√°s l√≥gica
}
```

**‚úÖ DESPU√âS: Sin Code Smells**
```java
private Set<Integer> convertCodes(List<String> codes) {
    return codes.stream()
        .filter(code -> code != null && !code.trim().isEmpty())
        .map(String::trim)
        .map(this::parse)
        .filter(Objects::nonNull)  // ‚úÖ Method reference
        .collect(Collectors.toSet());
}

public void processData(String id) {
    // ‚úÖ Sin inicializaci√≥n innecesaria
    List<DataDto> data = extractData(id);
    // ... m√°s l√≥gica
}

private List<DataDto> extractData(String id) {
    if (id != null) {
        return repository.findById(id);
    }
    return Collections.emptyList();
}
```

### Ejemplo 3: Validaciones con Early Return

**‚ùå ANTES: Validaciones anidadas**
```java
public ResponseDto process(RequestDto request) {
    if (request != null) {
        if (request.getData() != null) {
            if (!request.getData().isEmpty()) {
                // L√≥gica principal aqu√≠ (20+ l√≠neas)
                return processData(request.getData());
            } else {
                throw new ValidationException("Data vac√≠a");
            }
        } else {
            throw new ValidationException("Data null");
        }
    } else {
        throw new ValidationException("Request null");
    }
}
```

**‚úÖ DESPU√âS: Early Return + M√©todo de validaci√≥n**
```java
public ResponseDto process(RequestDto request) {
    validateRequest(request);
    return processData(request.getData());
}

private void validateRequest(RequestDto request) {
    if (request == null) {
        throw new ValidationException("Request null");
    }
    if (request.getData() == null) {
        throw new ValidationException("Data null");
    }
    if (request.getData().isEmpty()) {
        throw new ValidationException("Data vac√≠a");
    }
}
```

## üö´ Restricciones

1. **NO** crear m√©todos con complejidad cognitiva > 15 (ideal ‚â§ 10)
2. **NO** crear m√©todos > 50 l√≠neas sin refactorizar
3. **NO** dejar trailing whitespace (espacios al final de l√≠nea)
4. **NO** inicializar variables a `null` cuando se puede usar m√©todo que retorna valor
5. **NO** usar lambdas expl√≠citas cuando existe method reference (`Objects::nonNull`)
6. **NO** anidar m√°s de 3 niveles de validaciones (usar early return)
7. **NO** duplicar l√≥gica de validaci√≥n (extraer a m√©todo privado)
8. **NO** crear m√©todos privados sin JavaDoc descriptivo
9. **NO** ignorar warnings de SonarQube sin justificaci√≥n documentada
10. **NO** usar nombres gen√©ricos (`process()`, `handle()`, `execute()`) - ser espec√≠fico

## ‚úÖ Validaci√≥n Autom√°tica

Cursor debe detectar:

- ‚ùå M√©todos con complejidad cognitiva > 15
- ‚ùå M√©todos > 50 l√≠neas
- ‚ùå Trailing whitespace (espacios al final de l√≠nea)
- ‚ùå Inicializaci√≥n `= null` seguida de asignaci√≥n condicional
- ‚ùå Lambda `.filter(x -> x != null)` en lugar de `.filter(Objects::nonNull)`
- ‚ùå M√°s de 5 validaciones `if` consecutivas sin extraer
- ‚ùå M√∫ltiples niveles de anidaci√≥n (> 3)
- ‚ùå M√©todos privados sin JavaDoc
- ‚ùå Duplicaci√≥n de l√≥gica de validaci√≥n

## üéØ Objetivo + Regla de Oro

**Objetivo**: Mantener c√≥digo limpio, legible y mantenible que cumpla con los est√°ndares de calidad de SonarQube, minimizando la complejidad cognitiva.

**REGLA DE ORO**: "Si el m√©todo tiene m√°s de 3 validaciones o supera 30 l√≠neas, extraer m√©todos privados con nombres descriptivos. Cada m√©todo debe hacer UNA cosa bien. Complejidad cognitiva ‚â§ 10 es el objetivo."

---

## üìä M√©tricas de Calidad

| M√©trica | L√≠mite Cr√≠tico | L√≠mite Ideal | Acci√≥n |
|---------|----------------|--------------|---------|
| Complejidad Cognitiva | 15 | 10 | Extraer m√©todos |
| L√≠neas por m√©todo | 75 | 50 | Dividir m√©todo |
| Par√°metros | 7 | 4 | Usar DTO |
| Niveles anidaci√≥n | 4 | 3 | Early return |
| Duplicaci√≥n | 5% | 3% | Extraer com√∫n |

## üîß Estrategias de Refactorizaci√≥n

1. **Extract Method**: Extraer bloques l√≥gicos a m√©todos privados descriptivos
2. **Guard Clauses**: Usar early return para validaciones
3. **Method References**: Preferir `Objects::nonNull` sobre lambdas expl√≠citas
4. **Factory Methods**: Extraer construcci√≥n compleja a m√©todos dedicados
5. **Validation Methods**: Agrupar validaciones relacionadas

## üìù Convenciones de Nombres para M√©todos Privados

| Prop√≥sito | Prefijo/Patr√≥n | Ejemplo |
|-----------|----------------|---------|
| Validaci√≥n booleana | `should*`, `is*`, `has*` | `shouldReturnEmptyList()` |
| Extracci√≥n de datos | `extract*`, `get*` | `extractAllowedCodes()` |
| Conversi√≥n | `convert*`, `transform*` | `convertStringToInteger()` |
| Aplicaci√≥n de l√≥gica | `apply*`, `process*` | `applyPlanFilter()` |
| Construcci√≥n | `build*`, `create*` | `buildRequest()` |
| Validaci√≥n con throw | `validate*`, `ensure*` | `validateRequest()` |

---

> **Ver tambi√©n**: 
> - [servicios-01-creacion-servicios.mdc](./servicios-01-creacion-servicios.mdc) - Arquitectura de servicios
> - [servicios-04-excepciones.mdc](./servicios-04-excepciones.mdc) - Manejo de excepciones
