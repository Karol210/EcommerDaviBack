---
description: Controllers REST - Paths descriptivos y mejores pr√°cticas
globs: ["**/controller/**/*.java"]
alwaysApply: false
---

# üéÆ Controllers REST - Endpoints Autodocumentados

## üìã TL;DR

- ‚úÖ Paths descriptivos que explican la acci√≥n: `/create`, `/find-by-id/{id}`, `/update/{id}`
- ‚úÖ Patr√≥n consistente: `/acci√≥n` o `/acci√≥n/{id}`
- ‚úÖ Validaciones con `@Valid` en request DTOs
- ‚úÖ Responses con modelo `Response<T>` + HttpStatus correcto
- ‚úÖ **Controller SIN l√≥gica**: Solo recibe, delega al servicio y retorna
- ‚ùå NO paths ambiguos (`/{id}` para m√∫ltiples operaciones)
- ‚ùå NO hardcodear status codes (usar `HttpStatus.OK.value()`)
- ‚ùå **NO construir DTOs, Sort, Pageable ni l√≥gica de negocio en controller**

## üö® Reglas Principales

1. **Paths Descriptivos**: Cada endpoint debe tener un path que explique su acci√≥n (`/create`, `/update/{id}`, `/delete/{id}`, `/find-by-id/{id}`)
2. **Patr√≥n Consistente**: Seguir `/acci√≥n/{id}` para operaciones sobre entidad espec√≠fica, `/acci√≥n` para operaciones generales
3. **Validaciones Autom√°ticas**: `@Valid` en `@RequestBody`, validar par√°metros requeridos
4. **Status HTTP Correcto**: `CREATED (201)` para POST, `OK (200)` para GET/PUT/PATCH, usar `HttpStatus` enum
5. **Logs Informativos**: Log en cada endpoint con m√©todo HTTP, path y datos relevantes (NO sensibles)
6. **üî¥ CR√çTICO - Sin L√≥gica en Controller**: Controller SOLO recibe par√°metros, delega al servicio y construye Response. TODA la l√≥gica (construcci√≥n de DTOs, Sort, Pageable, mapeos, validaciones de negocio) va en el servicio

## üìä Referencia R√°pida

### Convenciones de Paths por Operaci√≥n

| Operaci√≥n | Verbo HTTP | Path Recomendado | Ejemplo Completo | Status |
|-----------|------------|------------------|------------------|--------|
| **Crear** | `POST` | `/create` | `POST /api/v1/users/create` | 201 |
| **Buscar por ID** | `GET` | `/find-by-id/{id}` | `GET /api/v1/users/find-by-id/1` | 200 |
| **Listar todos** | `GET` | `/all` | `GET /api/v1/users/all` | 200 |
| **Buscar con filtros** | `GET` | `/search` | `GET /api/v1/users/search?email=test` | 200 |
| **Buscar con paginaci√≥n** | `GET` | `/search/paginated` | `GET /api/v1/users/search/paginated` | 200 |
| **Actualizar** | `PUT` | `/update/{id}` | `PUT /api/v1/users/update/1` | 200 |
| **Eliminar** | `DELETE` | `/delete/{id}` | `DELETE /api/v1/users/delete/1` | 200 |
| **Activar/Desactivar** | `PATCH` | `/activate/{id}` | `PATCH /api/v1/users/activate/1` | 200 |
| **Cambio de estado** | `PATCH` | `/change-estado/{id}` | `PATCH /api/v1/users/change-password/1` | 200 |

### Estructura de Response Est√°ndar

| Campo | Tipo | Descripci√≥n | Ejemplo |
|-------|------|-------------|---------|
| `failure` | `boolean` | Indica si hubo error | `false` |
| `code` | `int` | Status HTTP | `200` |
| `message` | `String` | Mensaje descriptivo | `"Usuario creado exitosamente"` |
| `body` | `T` | Datos de respuesta | `UserResponseDto` |
| `timestamp` | `String` | Timestamp milisegundos | `"1699887600000"` |

### Anotaciones en Controllers

| Anotaci√≥n | Uso | Ejemplo |
|-----------|-----|---------|
| `@RestController` | Marca clase como controller REST | Obligatorio en clase |
| `@RequestMapping` | Path base del controller | `@RequestMapping("/api/v1/users")` |
| `@RequiredArgsConstructor` | Inyecci√≥n por constructor | Lombok |
| `@Slf4j` | Logger autom√°tico | Lombok |
| `@PostMapping("/path")` | Endpoint POST | Operaciones CREATE |
| `@GetMapping("/path")` | Endpoint GET | Operaciones READ |
| `@PutMapping("/path")` | Endpoint PUT | Operaciones UPDATE completo |
| `@PatchMapping("/path")` | Endpoint PATCH | Operaciones UPDATE parcial |
| `@DeleteMapping("/path")` | Endpoint DELETE | Operaciones DELETE |
| `@Valid` | Validar request DTO | `@Valid @RequestBody UserRequestDto` |
| `@PathVariable` | Variable en path | `@PathVariable Integer id` |
| `@RequestParam` | Query parameter | `@RequestParam(required = false) String email` |
| `@RequestBody` | Body del request | `@RequestBody UserRequestDto request` |

## ‚úÖ Ejemplos

### Ejemplo 1: Endpoint CREATE con Path Descriptivo

```java
/**
 * Crea un nuevo usuario.
 *
 * @param request Datos del usuario a crear
 * @return Response con el usuario creado
 */
@PostMapping("/create")
public ResponseEntity<Response<UserResponseDto>> createUser(
        @Valid @RequestBody UserRequestDto request) {

    log.info("POST /api/v1/users/create - Crear usuario: {}", request.getEmail());

    UserResponseDto user = userService.createUser(request);

    Response<UserResponseDto> response = Response.<UserResponseDto>builder()
            .failure(false)
            .code(HttpStatus.CREATED.value())  // ‚úÖ Status 201
            .message("Usuario creado exitosamente")
            .body(user)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build();

    return ResponseEntity.status(HttpStatus.CREATED).body(response);
}
```

**Caracter√≠sticas:**
- ‚úÖ Path `/create` expl√≠cito
- ‚úÖ Log con informaci√≥n relevante
- ‚úÖ `@Valid` para validaciones autom√°ticas
- ‚úÖ Status `201 CREATED` correcto
- ‚úÖ JavaDoc completo

### Ejemplo 2: Endpoint GET con Path Descriptivo

```java
/**
 * Obtiene un usuario por su ID.
 *
 * @param id ID del usuario
 * @return Response con el usuario encontrado
 */
@GetMapping("/find-by-id/{id}")
public ResponseEntity<Response<UserResponseDto>> getUserById(@PathVariable Integer id) {

    log.info("GET /api/v1/users/find-by-id/{} - Consultar usuario", id);

    UserResponseDto user = userService.getUserById(id);

    Response<UserResponseDto> response = Response.<UserResponseDto>builder()
            .failure(false)
            .code(HttpStatus.OK.value())  // ‚úÖ Status 200
            .message("Usuario encontrado")
            .body(user)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build();

    return ResponseEntity.ok(response);
}
```

**Beneficios:**
- ‚úÖ `/find-by-id/{id}` es autodocumentado
- ‚úÖ No ambig√ºedad con otros GET endpoints
- ‚úÖ Log con ID consultado

### Ejemplo 3: Endpoint PATCH con Path Descriptivo

```java
/**
 * Cambia la contrase√±a de un usuario.
 *
 * @param id ID del usuario
 * @param passwordRequest Request con la nueva contrase√±a
 * @return Response con confirmaci√≥n
 */
@PatchMapping("/change-password/{id}")
public ResponseEntity<Response<UserResponseDto>> changePassword(
        @PathVariable Integer id,
        @RequestBody PasswordChangeRequest passwordRequest) {

    log.info("PATCH /api/v1/users/change-password/{} - Cambiar contrase√±a", id);

    UserResponseDto user = userService.changePassword(id, passwordRequest.getNewPassword());

    Response<UserResponseDto> response = Response.<UserResponseDto>builder()
            .failure(false)
            .code(HttpStatus.OK.value())
            .message("Contrase√±a cambiada exitosamente")
            .body(user)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build();

    return ResponseEntity.ok(response);
}
```

**Caracter√≠sticas:**
- ‚úÖ `/change-password/{id}` muy expl√≠cito
- ‚úÖ PATCH para actualizaci√≥n parcial
- ‚úÖ DTO espec√≠fico para la operaci√≥n

### Ejemplo 4: Paths Descriptivos vs Ambiguos

| ‚ùå Ambiguo | ‚úÖ Descriptivo | Beneficio |
|-----------|---------------|-----------|
| `@PostMapping` | `@PostMapping("/create")` | Expl√≠cito: crea usuario |
| `@GetMapping("/{id}")` | `@GetMapping("/find-by-id/{id}")` | No se confunde con otros GET |
| `@PutMapping("/{id}")` | `@PutMapping("/update/{id}")` | Indica actualizaci√≥n completa |
| `@PatchMapping("/{id}/activate")` | `@PatchMapping("/activate/{id}")` | Patr√≥n consistente `/acci√≥n/{id}` |

**Beneficios del patr√≥n descriptivo:**
- üéØ **Autodocumentados** sin necesidad de comentarios
- üéØ **Consistentes** con patr√≥n `/acci√≥n/{id}` uniforme
- üéØ **Sin conflictos** de rutas ni ambig√ºedad

## üö´ Restricciones

1. **NO** usar paths ambiguos (`@PostMapping`, `@GetMapping("/{id}")` sin contexto)
2. **NO** mezclar patrones (`/{id}/acci√≥n` y `/acci√≥n/{id}` en el mismo controller)
3. **NO** hardcodear status codes (`response.setStatus(200)` ‚Üí usar `HttpStatus.OK`)
4. **NO** omitir `@Valid` en DTOs de entrada
5. **NO** loguear informaci√≥n sensible (contrase√±as, tokens, datos personales sin enmascarar)
6. **NO** retornar tipos primitivos o DTOs directamente (usar `ResponseEntity<Response<T>>`)
7. **NO** usar m√∫ltiples `@RequestMapping` con valores diferentes en la misma clase
8. **NO** omitir JavaDoc en m√©todos p√∫blicos del controller
9. **NO** crear endpoints sin logs informativos
10. **NO** usar `ResponseEntity.ok()` para errores (usar status apropiado)
11. **üî¥ NO construir DTOs en controller** (`ProductFilterDto.builder()...` ‚Üí mover al servicio)
12. **üî¥ NO construir Sort/Pageable en controller** (`Sort.by()`, `PageRequest.of()` ‚Üí mover al servicio)
13. **üî¥ NO realizar mapeos en controller** (transformaciones DTO ‚Üí Entity ‚Üí mover al servicio)
14. **üî¥ NO validaciones de negocio en controller** (solo `@Valid` autom√°tico, validaciones complejas ‚Üí servicio)
15. **üî¥ NO c√°lculos o procesamiento de datos** (toda l√≥gica ‚Üí servicio)

## ‚úÖ Validaci√≥n Autom√°tica

Cursor debe detectar:

**Paths:**
- ‚ùå `@PostMapping` sin path espec√≠fico
- ‚ùå `@GetMapping("/{id}")` sin prefijo descriptivo
- ‚ùå `@PutMapping("/{id}")` sin prefijo descriptivo
- ‚ùå Patrones inconsistentes (`/{id}/acci√≥n` mezclado con `/acci√≥n/{id}`)
- ‚ùå Paths sin guiones donde corresponde (`/findbyid` ‚Üí `/find-by-id`)

**Responses:**
- ‚ùå Hardcoded status codes (`200`, `201` ‚Üí `HttpStatus.OK.value()`)
- ‚ùå Retorno directo de DTOs sin `ResponseEntity<Response<T>>`
- ‚ùå Falta de `failure`, `code`, `message`, `body`, `timestamp` en Response

**Validaciones:**
- ‚ùå `@RequestBody` sin `@Valid` en operaciones CREATE/UPDATE
- ‚ùå Falta de logs en endpoints
- ‚ùå Logs con informaci√≥n sensible

**Documentaci√≥n:**
- ‚ùå M√©todos p√∫blicos sin JavaDoc
- ‚ùå JavaDoc sin descripci√≥n de par√°metros (`@param`)
- ‚ùå JavaDoc sin descripci√≥n de retorno (`@return`)

**üî¥ L√≥gica en Controller (CR√çTICO):**
- ‚ùå `.builder()` en controller (construcci√≥n de DTOs)
- ‚ùå `Sort.by()` o `PageRequest.of()` en controller
- ‚ùå Imports de `PageRequest`, `Sort` en controller (se√±al de l√≥gica de paginaci√≥n)
- ‚ùå Mapeos o transformaciones de datos (`.map()`, conversiones)
- ‚ùå Condicionales de negocio (`if (price > 100)`, `if (user.isActive())`)
- ‚ùå C√°lculos (`total = price * quantity`, `discount = ...`)
- ‚ùå M√∫ltiples l√≠neas de l√≥gica antes de llamar al servicio

### Ejemplo 5: Controller Sin L√≥gica vs Con L√≥gica

| Aspecto | ‚ùå CON L√≥gica en Controller | ‚úÖ SIN L√≥gica (Delega) |
|---------|----------------------------|----------------------|
| **Construcci√≥n DTOs** | `ProductFilterDto.builder()...` en controller | Servicio construye DTO internamente |
| **Paginaci√≥n** | `Sort.by()`, `PageRequest.of()` en controller | Servicio maneja Sort/Pageable |
| **Transformaciones** | `.map()`, conversiones en controller | Servicio retorna DTO final |
| **Testabilidad** | Mockear m√∫ltiples dependencias | Mockear solo 1 servicio |
| **Responsabilidad** | M√∫ltiples: construir, ordenar, transformar | Una: recibir, delegar, retornar |

**‚ùå PROBLEMAS del controller con l√≥gica:**
```java
// ‚ùå Construcci√≥n de DTO en controller
ProductFilterDto filter = ProductFilterDto.builder()...build();

// ‚ùå L√≥gica de paginaci√≥n en controller
Sort sort = sortDir.equals("desc") ? Sort.by(sortBy).descending() : ...;
Pageable pageable = PageRequest.of(page, size, sort);
```

**‚úÖ CORRECTO - Controller limpio:**
```java
@GetMapping("/search/paginated")
public ResponseEntity<Response<PagedProductResponseDto>> search(...params) {
    log.info("GET /search/paginated - Buscar con filtros");
    
    // ‚úÖ Solo delega al servicio (toda l√≥gica est√° all√≠)
    Page<ProductResponseDto> page = service.searchPaginated(
            categoryId, minPrice, maxPrice, active, searchTerm,
            page, size, sortBy, sortDir);
    
    return ResponseEntity.ok(buildResponse(page));
}
```

**Regla de 3 L√≠neas:** Controller debe tener m√°ximo: 1) Log 2) Llamada servicio 3) Construir Response

## üéØ Objetivo + Regla de Oro

**Objetivo**: Crear controllers con endpoints autodocumentados, paths descriptivos y respuestas consistentes que faciliten el mantenimiento y comprensi√≥n de la API. **Controller sin l√≥gica de negocio**.

**REGLA DE ORO**: "Path descriptivo = Acci√≥n expl√≠cita. Patr√≥n: `/acci√≥n/{id}`. Response est√°ndar con `HttpStatus` enum. `@Valid` en inputs. Logs informativos sin datos sensibles. JavaDoc completo. **Controller SOLO recibe ‚Üí delega ‚Üí retorna. TODA l√≥gica en servicio**."

---

> **Ver tambi√©n**: 
> - [servicios-01-creacion-servicios.mdc](./servicios-01-creacion-servicios.mdc) - Arquitectura en capas
> - [servicios-05-dtos.mdc](./servicios-05-dtos.mdc) - Estructura de DTOs
> - [servicios-10-buenas-practicas.mdc](./servicios-10-buenas-practicas.mdc) - Buenas pr√°cticas generales
